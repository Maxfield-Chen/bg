-- File auto generated by purescript-bridge! --
module Game where

import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map.Internal (Map)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype)
import Data.Set.Internal (Set)
import Data.Symbol (SProxy(SProxy))
import Data.Tuple (Tuple)
import Prim (Array, Int, Number)

import Prelude

data Pair Int =
    Pair Int Int

derive instance eqPair :: Eq (Pair Int)
derive instance ordPair :: Ord (Pair Int)
derive instance genericPair :: Generic Int rInt => Generic (Pair Int) _

--------------------------------------------------------------------------------
_Pair :: forall Int. Prism' (Pair Int) { a :: Int, b :: Int }
_Pair = prism' (\{ a, b } -> Pair a b) f
  where
    f (Pair a b) = Just $ { a: a, b: b }

--------------------------------------------------------------------------------
data GameStatus =
    GameRejected
  | GameProposed
  | InProgress
  | CountingProposed
  | CountingAccepted
  | TerritoryProposed
  | TerritoryAccepted

derive instance eqGameStatus :: Eq GameStatus
derive instance genericGameStatus :: Generic GameStatus _

--------------------------------------------------------------------------------
_GameRejected :: Prism' GameStatus Unit
_GameRejected = prism' (\_ -> GameRejected) f
  where
    f GameRejected = Just unit
    f _ = Nothing

_GameProposed :: Prism' GameStatus Unit
_GameProposed = prism' (\_ -> GameProposed) f
  where
    f GameProposed = Just unit
    f _ = Nothing

_InProgress :: Prism' GameStatus Unit
_InProgress = prism' (\_ -> InProgress) f
  where
    f InProgress = Just unit
    f _ = Nothing

_CountingProposed :: Prism' GameStatus Unit
_CountingProposed = prism' (\_ -> CountingProposed) f
  where
    f CountingProposed = Just unit
    f _ = Nothing

_CountingAccepted :: Prism' GameStatus Unit
_CountingAccepted = prism' (\_ -> CountingAccepted) f
  where
    f CountingAccepted = Just unit
    f _ = Nothing

_TerritoryProposed :: Prism' GameStatus Unit
_TerritoryProposed = prism' (\_ -> TerritoryProposed) f
  where
    f TerritoryProposed = Just unit
    f _ = Nothing

_TerritoryAccepted :: Prism' GameStatus Unit
_TerritoryAccepted = prism' (\_ -> TerritoryAccepted) f
  where
    f TerritoryAccepted = Just unit
    f _ = Nothing

--------------------------------------------------------------------------------
data Outcome =
    NoKill
  | Kill

derive instance eqOutcome :: Eq Outcome
derive instance genericOutcome :: Generic Outcome _

--------------------------------------------------------------------------------
_NoKill :: Prism' Outcome Unit
_NoKill = prism' (\_ -> NoKill) f
  where
    f NoKill = Just unit
    f _ = Nothing

_Kill :: Prism' Outcome Unit
_Kill = prism' (\_ -> Kill) f
  where
    f Kill = Just unit
    f _ = Nothing

--------------------------------------------------------------------------------
data MoveError =
    IllegalPlayer
  | NoBoard
  | IllegalKo
  | Suicide
  | OutOfBounds
  | Occupied

derive instance eqMoveError :: Eq MoveError
derive instance genericMoveError :: Generic MoveError _

--------------------------------------------------------------------------------
_IllegalPlayer :: Prism' MoveError Unit
_IllegalPlayer = prism' (\_ -> IllegalPlayer) f
  where
    f IllegalPlayer = Just unit
    f _ = Nothing

_NoBoard :: Prism' MoveError Unit
_NoBoard = prism' (\_ -> NoBoard) f
  where
    f NoBoard = Just unit
    f _ = Nothing

_IllegalKo :: Prism' MoveError Unit
_IllegalKo = prism' (\_ -> IllegalKo) f
  where
    f IllegalKo = Just unit
    f _ = Nothing

_Suicide :: Prism' MoveError Unit
_Suicide = prism' (\_ -> Suicide) f
  where
    f Suicide = Just unit
    f _ = Nothing

_OutOfBounds :: Prism' MoveError Unit
_OutOfBounds = prism' (\_ -> OutOfBounds) f
  where
    f OutOfBounds = Just unit
    f _ = Nothing

_Occupied :: Prism' MoveError Unit
_Occupied = prism' (\_ -> Occupied) f
  where
    f Occupied = Just unit
    f _ = Nothing

--------------------------------------------------------------------------------
data Space =
    Black
  | White
  | Empty

derive instance eqSpace :: Eq Space
derive instance ordSpace :: Ord Space
derive instance genericSpace :: Generic Space _

--------------------------------------------------------------------------------
_Black :: Prism' Space Unit
_Black = prism' (\_ -> Black) f
  where
    f Black = Just unit
    f _ = Nothing

_White :: Prism' Space Unit
_White = prism' (\_ -> White) f
  where
    f White = Just unit
    f _ = Nothing

_Empty :: Prism' Space Unit
_Empty = prism' (\_ -> Empty) f
  where
    f Empty = Just unit
    f _ = Nothing

--------------------------------------------------------------------------------
newtype Game =
    Game {
      _boardSize :: Int
    , _record :: Array GameState
    , _komi :: Number
    , _finalTerritory :: Map Space (Set (Pair Int))
    , _finalScore :: Tuple Number Number
    , _status :: GameStatus
    }

derive instance eqGame :: Eq Game
derive instance genericGame :: Generic Game _
derive instance newtypeGame :: Newtype Game _

--------------------------------------------------------------------------------
_Game :: Iso' Game { _boardSize :: Int, _record :: Array GameState, _komi :: Number, _finalTerritory :: Map Space (Set (Pair Int)), _finalScore :: Tuple Number Number, _status :: GameStatus}
_Game = _Newtype

boardSize :: Lens' Game Int
boardSize = _Newtype <<< prop (SProxy :: SProxy "_boardSize")

record :: Lens' Game (Array GameState)
record = _Newtype <<< prop (SProxy :: SProxy "_record")

komi :: Lens' Game Number
komi = _Newtype <<< prop (SProxy :: SProxy "_komi")

finalTerritory :: Lens' Game (Map Space (Set (Pair Int)))
finalTerritory = _Newtype <<< prop (SProxy :: SProxy "_finalTerritory")

finalScore :: Lens' Game (Tuple Number Number)
finalScore = _Newtype <<< prop (SProxy :: SProxy "_finalScore")

status :: Lens' Game GameStatus
status = _Newtype <<< prop (SProxy :: SProxy "_status")

--------------------------------------------------------------------------------
newtype GameState =
    GameState {
      _board :: Map (Pair Int) Space
    , _toPlay :: Space
    , _captures :: Map Space Int
    }

derive instance eqGameState :: Eq GameState
derive instance genericGameState :: Generic GameState _
derive instance newtypeGameState :: Newtype GameState _

--------------------------------------------------------------------------------
_GameState :: Iso' GameState { _board :: Map (Pair Int) Space, _toPlay :: Space, _captures :: Map Space Int}
_GameState = _Newtype

board :: Lens' GameState (Map (Pair Int) Space)
board = _Newtype <<< prop (SProxy :: SProxy "_board")

toPlay :: Lens' GameState Space
toPlay = _Newtype <<< prop (SProxy :: SProxy "_toPlay")

captures :: Lens' GameState (Map Space Int)
captures = _Newtype <<< prop (SProxy :: SProxy "_captures")

--------------------------------------------------------------------------------
newtype Group =
    Group {
      _liberties :: Set (Pair Int)
    , _members :: Set (Pair Int)
    , _player :: Space
    }

derive instance eqGroup :: Eq Group
derive instance genericGroup :: Generic Group _
derive instance newtypeGroup :: Newtype Group _

--------------------------------------------------------------------------------
_Group :: Iso' Group { _liberties :: Set (Pair Int), _members :: Set (Pair Int), _player :: Space}
_Group = _Newtype

liberties :: Lens' Group (Set (Pair Int))
liberties = _Newtype <<< prop (SProxy :: SProxy "_liberties")

members :: Lens' Group (Set (Pair Int))
members = _Newtype <<< prop (SProxy :: SProxy "_members")

player :: Lens' Group Space
player = _Newtype <<< prop (SProxy :: SProxy "_player")

--------------------------------------------------------------------------------
